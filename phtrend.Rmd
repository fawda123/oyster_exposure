---
title: "pH time series decomposition"
author: "M. W. Beck"
output: html_document
---

# {.tabset}

## Theory

First load relevant libraries.

```{r setup, warning = F, message = F}
library(knitr)
library(tidyverse)
library(lubridate)
library(readxl)
library(here)
library(oce)
library(downloadthis)

opts_chunk$set(warning = FALSE, message = FALSE)
```

Import the Padilla Bay data, convert the time zone to Pacific, no DST.

```{r}
# read Padilla Bay data
pddat <- read.csv(here('data/raw/pdbbyph.csv')) %>% 
  mutate(
    DateTimeStamp = ymd_hms(DateTimeStamp, tz = 'Pacific/Pitcairn')
  )
```

Let's just subset to hourly observations to reduce size of the data.  We should still be able to detect dominant periods from these data.  We also add a column for decimal time so we can model the long-term, annual trend. The plot shows the whole time series.

```{r, fig.height = 3, fig.width= 12}
pddat <- pddat %>% 
  filter(minute(DateTimeStamp) == 0) %>% 
  mutate(dectime = decimal_date(DateTimeStamp))

plot(pH ~ DateTimeStamp, data = pddat, type = 'l')
```

We can fit a sinusoidal linear model to the decimal time argument to isolate the seasonal trend. 
```{r, fig.height = 4, fig.width = 9}
# fit model
annmod <- lm(pH ~ sin(2*pi*dectime) + cos(2*pi*dectime), data = pddat, na.action = na.exclude)
```

Now we add the annual predictions to the data and subtract them from pH to get a detrended time series without the long-term, annual trend.
```{r, fig.height = 3, fig.width = 12}
pdprd <- pddat %>% 
  mutate(
    ph_ann = predict(annmod),
    ph_anndtrn = pH - ph_ann
  )

plot(ph_ann ~ DateTimeStamp, data = pdprd, type = 'l')
plot(ph_anndtrn ~ DateTimeStamp, data = pdprd, type = 'l')
```

Now we can cheat and assume that the daily/sub-daily time series does not change between years.  So, we subset one year of data for ease of analysis.  We also subset the summer months since we know the time series is non-stationary throughout the year (amplitudes change).
```{r, fig.height = 3, fig.width = 12}
pdsub <- pdprd %>% 
  filter(year(DateTimeStamp) == 2015) %>% 
  filter(month(DateTimeStamp) %in% c(5:8))

plot(ph_anndtrn ~ DateTimeStamp, data = pdsub, type = 'l')
```    

Next we want to predict the daily periodicity.  Once that is isolated and removed, the rest can be attributed to tidal variation.

```{r}
# decimal days
pdsub <- pdsub %>% 
  mutate(
    decdays =  365 * (decimal_date(DateTimeStamp) - max(year(DateTimeStamp)))
  )

dlymod <- lm(ph_anndtrn ~ sin(2*pi*decdays) + cos(2*pi*decdays), data = pdsub, na.action = na.exclude)
```

Now we remove the daily signal from the detrended annual pH time series just like we did for the annual signal.

```{r, fig.height = 3, fig.width = 12}
pdsub <- pdsub %>% 
  mutate(
    ph_dly = predict(dlymod),
    ph_dlydtrn = ph_anndtrn - ph_dly
  )

plot(ph_dly ~ DateTimeStamp, data = pdsub, type = 'l')
plot(ph_dlydtrn ~ DateTimeStamp, data = pdsub, type = 'l')
```


After we've removed the annual and daily periodicity from the time series, the rest can be considered tidal fluctuation (and other residual variation). We can use harmonic regression to predict multiple sine waves for the major constituents in the residual data.  The oce R package has a function to predict tidal components but it can work equally well for other time series with different periods.  First, we plot the power spectrum to identify dominant peaks.

```{r, fig.height = 4, fig.width = 9}
spectrum(pdsub$ph_dlydtrn, log = 'no', xlim = c(0, 0.1))
```

To use the oce functions, we have to convert the data into a 'sealevel' object.  The plot below confirms where we see the dominant peaks in the spectrum plot.

```{r, fig.height = 8, fig.width = 8}
datsl <- as.sealevel(elevation = pdsub$ph_dlydtrn, time = pdsub$DateTimeStamp)
plot(datsl)
```

Setup the harmonic regression and get predictions for the five main tidal constituents.

```{r, fig.height = 5, fig.width = 8}
# tidal components to estimate
constituents <- c('M2', 'S2', 'N2', 'K1', 'O1')

# loop through tidal components, predict each with tidem
preds <- sapply(constituents, function(x){

  mod <- tidem(t = datsl, constituent = x)
  pred <- predict(mod)
  pred - mean(pred)

})

# prep for plot
subs <- 1:50
toplo <- preds[subs, ] %>%
  data.frame %>%
  mutate(time = pdsub$DateTimeStamp[subs]) %>%
  gather('component', 'estimate', -time) %>%
  mutate(component = factor(component, level = c('Estimated', constituents)))

# plot two weeks
ggplot(toplo, aes(x = time, y = estimate, group = component)) +
  geom_line() +
  # scale_x_datetime(limits = as.POSIXct(c('2013-07-01', '2013-07-31'))) +
  facet_wrap(~component, ncol = 1) +
  theme_bw()
```

Now we can add the predictions back to the annual, seasonal data frame to see how well the sum of the predictions modeled actual pH. 

```{r, fig.height = 5, fig.width = 9}
pdsub <- pdsub %>% 
  mutate(
    K1 = data.frame(preds)[['K1']],
    O1 = data.frame(preds)[['O1']],
    S2 = data.frame(preds)[['S2']],
    N2 = data.frame(preds)[['N2']],
    M2 = data.frame(preds)[['M2']]
  ) %>% 
  rowwise() %>% 
  mutate(
    ph_mod = sum(ph_ann, ph_dly, K1, O1, S2, N2, M2)
  ) %>% 
  ungroup()

toplo <- pdsub %>% 
  select(DateTimeStamp, ph_mod, pH) %>% 
  gather('var', 'val', -DateTimeStamp)
subs <- 1:200

p1 <- ggplot(toplo, aes(x = DateTimeStamp, y = val)) + 
  geom_line() +
  scale_x_datetime(limits = range(toplo$DateTimeStamp[subs])) +
  facet_wrap(~var, ncol = 1, strip.position = 'left') + 
  theme(
    strip.placement = 'outside', 
    strip.background = element_blank(), 
    axis.title = element_blank()
  )
p2 <- ggplot(toplo, aes(x = DateTimeStamp, y = val)) + 
  geom_line() +
  facet_wrap(~var, ncol = 1, strip.position = 'left') + 
  theme(
    strip.placement = 'outside', 
    strip.background = element_blank(), 
    axis.title = element_blank()
  )
p1
p2
```

To get the amplitudes of each component, we can just check the ranges and add the mean pH back to the sine wave components. 

```{r}
rngs <- pdsub %>% 
  select(ph_dly, K1, O1, S2, N2, M2) %>% 
  mutate(
    ph_dly = ph_dly - mean(ph_dly, na.rm = T)
  ) %>% 
  gather('var', 'val') %>% 
  group_by(var) %>% 
  summarise(
    minv = min(val, na.rm = T), 
    maxv = max(val, na.rm = T),
    .groups = 'drop'
  )

ann <- range(pdprd$ph_ann, na.rm = T) %>% 
  diff %>% 
  `/`(2) %>% 
  tibble(
    var = 'ann', 
    minv = ., 
    maxv = .
  ) %>% 
  mutate(
    minv = -1 * minv
  )

rngs <- bind_rows(rngs, ann) %>% 
  mutate(
    var = factor(var, 
                 levels = c('ann', 'ph_dly', 'K1', 'O1', 'M2', 'S2', 'N2'), 
                 labels = c('Annual', 'Daily', 'K1', 'O1', 'M2', 'S2', 'N2')
                 )
  )

ggplot(rngs, aes(x = var)) + 
  geom_errorbar(aes(ymin = minv, ymax = maxv)) + 
  geom_hline(yintercept = 0, linetype = 'dotted') + 
  theme_minimal() + 
  theme(
    panel.grid.major.x = element_blank(), 
    panel.grid.minor.y = element_blank(), 
    panel.grid.minor.x = element_blank()
  ) +
  labs(
    y = 'pH range', 
    x = NULL
  )
```

Finally, it may be useful to evaluate the min/max values in each day using both all of the additive components.  These components can be in-phase or out-of-phase causing higher or lower ranges than the individual amplitudes of each component.  This provides a more realistic interpretation of what an organism maybe exposed in any given day. 

```{r, fig.width = 5, fig.height = 5}
pddlyrng <- pdsub %>% 
  mutate(
    dy = yday(DateTimeStamp)
  ) %>% 
  group_by(dy) %>% 
  summarise(
    minph = min(ph_mod, na.rm = T),
    maxph = max(ph_mod, na.rm = T),
    .groups = 'drop'
  ) %>% 
  mutate(
    phdff = maxph - minph
  )

ggplot(pddlyrng, aes(x = phdff)) + 
  geom_histogram() + 
  theme_minimal() + 
  labs(
    x = 'pH range', 
    y = 'Density'
  )
```

## All sites

The methods were repeated for all sites to identify dominant periods and their amplitudes. 

```{r}
phres <- tibble(
    site = c('kacss', 'sfbcc', 'sfbgc', 'tjrbr'), 
    tz = c('Pacific/Gambier', 'Pacific/Pitcairn', 'Pacific/Pitcairn', 'Pacific/Pitcairn')
  ) %>% 
  group_by(site, tz) %>% 
  nest() %>% 
  # select(-data) %>% 
  mutate(
    annprd = pmap(list(site, tz, data), function(site, tz, data){
      
      fl <- paste0('data/raw/', site, 'ph.csv')
      dat <- read.csv(here(fl)) %>% 
        mutate(
          DateTimeStamp = ymd_hms(DateTimeStamp, tz = tz)
        ) %>% 
        filter(minute(DateTimeStamp) == 0) %>% 
        filter(year(DateTimeStamp) >= 2010 & year(DateTimeStamp) < 2021) %>% 
        mutate(dectime = decimal_date(DateTimeStamp))
      
      annmod <- lm(pH ~ sin(2*pi*dectime) + cos(2*pi*dectime), data = dat, na.action = na.exclude)
      
      out <- dat %>% 
        mutate(
          ph_ann = predict(annmod),
          ph_anndtrn = pH - ph_ann
        )
      
      return(out)
      
    }),
    sumval = map(annprd, function(annprd){
      
      out <- tibble(
        avev = mean(annprd$pH, na.rm = T),
        minv = min(annprd$pH, na.rm = T),
        maxv = max(annprd$pH, na.rm = T),
        sdv = sd(annprd$pH, na.rm = T)
      )
      
      return(out)

    }), 
    dlyprd = map(annprd, function(annprd){
      
      datsub <- annprd %>% 
        filter(year(DateTimeStamp) == 2012) %>% 
        filter(month(DateTimeStamp) %in% c(5:8)) %>% 
        mutate(
          decdays =  365 * (decimal_date(DateTimeStamp) - max(year(DateTimeStamp)))
        )
      
      dlymod <- lm(ph_anndtrn ~ sin(2*pi*decdays) + cos(2*pi*decdays), data = datsub, na.action = na.exclude)
    
      dlyprd <- datsub %>% 
        mutate(
          ph_dly = predict(dlymod),
          ph_dlydtrn = ph_anndtrn - ph_dly
        )

      datsl <- as.sealevel(elevation = dlyprd$ph_dlydtrn, time = dlyprd$DateTimeStamp)

      constituents <- c('M2', 'S2', 'N2', 'K1', 'O1')
      
      # loop through tidal components, predict each with tidem
      preds <- sapply(constituents, function(x){
        
        mod <- tidem(t = datsl, constituent = x)
        pred <- predict(mod)
        pred - mean(pred, na.rm = T)
        
      })
    
      out <- dlyprd %>% 
        mutate(
          K1 = data.frame(preds)[['K1']],
          O1 = data.frame(preds)[['O1']],
          S2 = data.frame(preds)[['S2']],
          N2 = data.frame(preds)[['N2']],
          M2 = data.frame(preds)[['M2']]
        ) %>% 
        rowwise() %>% 
        mutate(
          ph_mod = sum(ph_ann, ph_dly, K1, O1, S2, N2, M2)
        ) %>% 
        ungroup()
      
      return(out)
      
    }),
    rngs = pmap(list(dlyprd, annprd), function(dlyprd, annprd){
      
      rngs <- dlyprd %>% 
        select(ph_dly, K1, O1, S2, N2, M2) %>% 
        mutate(
          ph_dly = ph_dly - mean(ph_dly, na.rm = T)
        ) %>% 
        gather('var', 'val') %>% 
        group_by(var) %>% 
        summarise(
          minv = min(val, na.rm = T), 
          maxv = max(val, na.rm = T),
          .groups = 'drop'
        )
      
      ann <- range(annprd$ph_ann, na.rm = T) %>% 
        diff %>% 
        `/`(2) %>% 
        tibble(
          var = 'ann', 
          minv = ., 
          maxv = .
        ) %>% 
        mutate(
          minv = -1 * minv
        )
      
      out <- bind_rows(rngs, ann) %>% 
        mutate(
          var = factor(var, 
                       levels = c('ann', 'ph_dly', 'K1', 'O1', 'M2', 'S2', 'N2'), 
                       labels = c('Annual', 'Daily', 'K1', 'O1', 'M2', 'S2', 'N2')
          )
        )
      
      return(out)
      
    }),
    dlyrng = map(dlyprd, function(dlyprd){
 
      out <- dlyprd %>% 
        mutate(
          dy = yday(DateTimeStamp)
        ) %>% 
        group_by(dy) %>% 
        summarise(
          minph = ifelse(length(na.omit(ph_mod)) > 0, min(ph_mod, na.rm = T), NA),
          maxph = ifelse(length(na.omit(ph_mod)) > 0, max(ph_mod, na.rm = T), NA),
          .groups = 'drop'
        ) %>% 
        mutate(
          phdff = (maxph - minph) / 2
        )
      
      return(out)
      
    })
  ) %>% 
  mutate(site = toupper(site))
```

pH time series for all sites. 

```{r, fig.height = 9, fig.width = 9}
annplo <- phres %>% 
  select(annprd) %>% 
  unnest('annprd') 

p <- ggplot(annplo, aes(x = DateTimeStamp, y = pH)) + 
  geom_line() + 
  facet_wrap(~site, ncol = 1) + 
  theme_minimal() +
  labs(
    x = NULL
  )
p
```

April to August time series for 2012 used to predict daily and tidal components. 
```{r, fig.height = 9, fig.width = 9}
dlyplo <- phres %>% 
  select(dlyprd) %>% 
  unnest('dlyprd')

p <- ggplot(dlyplo, aes(x = DateTimeStamp, y = pH)) + 
  geom_line() + 
  facet_wrap(~StationCode, ncol = 1) + 
  theme_minimal() +
  labs(
    x = NULL
  )
p
```

Estimated amplitudes for annual, daily, and tidal components for each site. 

```{r, fig.height = 8, fig.width = 5}

rngplo <- phres %>% 
  select(rngs) %>% 
  unnest('rngs')

ggplot(rngplo, aes(x = var)) + 
  geom_errorbar(aes(ymin = minv, ymax = maxv)) + 
  geom_hline(yintercept = 0, linetype = 'dotted') + 
  facet_wrap(~site, ncol = 1) +
  theme_minimal() + 
  theme(
    panel.grid.major.x = element_blank(), 
    panel.grid.minor.y = element_blank(), 
    panel.grid.minor.x = element_blank()
  ) +
  labs(
    y = 'pH range', 
    x = NULL
  )
```

Distribution of total range of pH across days from May to August 2012. 

```{r, fig.height = 7, fig.width = 6}
dlyrngplo <- phres %>% 
  select(dlyrng) %>% 
  unnest('dlyrng')

ggplot(dlyrngplo, aes(x = phdff)) + 
  geom_histogram() + 
  facet_wrap(~site, ncol = 1) + 
  theme_minimal() + 
  labs(
    x = 'daily pH amplitude, May-Aug', 
    y = 'Density'
  )
```

Tabular summary of site characteristics:

```{r, echo = F}
totab1 <- phres %>% 
  select(sumval) %>% 
  unnest('sumval') %>% 
  ungroup() %>% 
  mutate_if(is.numeric, round, 2) %>% 
  mutate(
    avev = paste0(avev, ' '), 
    minv = paste0('(', minv, ', '), 
    maxv = paste0(maxv, ')')
  ) %>% 
  unite('rng', avev, minv, maxv, sep = '') %>% 
  select(-tz)

totab2 <- phres %>% 
  select(rngs) %>% 
  unnest('rngs') %>% 
  ungroup() %>% 
  select(site, var, amp = maxv) %>% 
  mutate(
    amp = round(amp, 3)
  ) %>% 
  spread(var, amp)

totab3 <- phres %>% 
  select(dlyrng) %>% 
  unnest('dlyrng') %>% 
  group_by(site) %>% 
  filter((phdff %in% min(phdff, na.rm = T)) | (phdff %in% max(phdff, na.rm = T))) %>% 
  mutate(
    var = case_when(
      phdff == min(phdff) ~ 'min daily', 
      phdff == max(phdff) ~ 'max daily'
    )
  ) %>% 
  ungroup() %>% 
  select(site, phdff, var) %>% 
  spread(var, phdff) %>% 
  mutate_if(is.numeric, round, 2)

totab <- full_join(totab1, totab3, by = 'site') %>% 
  full_join(totab2, by = 'site') %>% 
  gather('Summary', 'val', -site) %>% 
  mutate(
    Summary = factor(Summary, 
                levels = c('rng', 'sdv', 'Annual', 'Daily', 'O1', 'K1', 'N2', 'S2', 'M2', 'min daily', 'max daily'),
                labels = c('Ave (min, max)', 'St. Dev',  'Annual', 'Daily', 'O1', 'K1', 'N2', 'S2', 'M2', 'min daily', 'max daily')
                )
  ) %>% 
  spread(site, val) %>% 
  arrange(Summary)

download_this(
  totab,
  output_name = "ph-summmary",
  output_extension = ".xlsx",
  button_label = "Download data",
  button_type = "warning",
  has_icon = TRUE,
  icon = "fa fa-save"
)

knitr::kable(totab, caption = 'Summary statistics of pH for four NERRS sites (Kachemak Bay Seldovia Surface, San Francisco Bay China Camp, San Francisco Bay Gallinas Creek, and Tijuana River Boca Rio).  Summaries include average (min/max) and standard deviation from a ten year record from 2010 to 2020 and estimates of amplitudes for decomposed periods from the pH time series.  The annual amplitude is estimated from the complete time series, whereas the daily, and tidal constituents (O1 25.82 hours, K1 23.93, N2 12.66, S2 12, and M2 12.42) are based on estimates from May to August 2012.  The min and max daily amplitudes represent the range of amplitudes observed as the sum of the separate components from the above rows.')
```

